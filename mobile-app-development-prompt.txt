================================================================================
FLUTTER MOBILE APP DEVELOPMENT PROMPT - IASTAM OFFICER CHECK-IN APP
================================================================================
Version: 1.0
Platform: Flutter (iOS & Android)
Purpose: Officer-only session check-in via QR scan or manual search
Backend: NestJS REST API + Socket.io WebSocket
================================================================================

================================================================================
PROMPT START
================================================================================

Create a Flutter mobile application for conference officers to perform 
participant check-ins at  conference sessions. This is a lightweight,
single-purpose app focused on reliability and speed.

================================================================================
PROJECT OVERVIEW
================================================================================

App Name: Checkin Officer Check-In
Package Name: com.checkin
Min SDK: Android 21 (5.0) / iOS 12.0
Target: Android & iOS

Core Features:
1. Session list with real-time status (open/closed/ended)
2. QR code scanning for instant check-in
3. Manual participant search + check-in
4. Offline queue with auto-sync
5. Real-time WebSocket updates

================================================================================
BACKEND API CONFIGURATION
================================================================================

Base URL: http://{SERVER_IP}:3000/api/v1
WebSocket: http://{SERVER_IP}:3000/realtime

Key Endpoints:
- GET  /sessions - List sessions (paginated)
- GET  /sessions/:id - Session details
- GET  /sessions/:id/checkins - Session check-ins
- POST /checkin/qr - QR check-in { qrCode, sessionId, checkedInBy }
- POST /checkin - Manual check-in { participantId, sessionId, method, checkedInBy }
- GET  /checkin/verify/:participantId/:sessionId - Verify if checked in
- GET  /participants?search=xxx - Search participants
- GET  /participants/qr/:qrCode - Find by QR code
- GET  /health/live - Connection test

WebSocket Events:
- Connect to /realtime namespace
- Emit: 'subscribe:sessions' to receive updates
- Listen: 'sessions:status-update' for status changes
- Listen: 'sessions:checkin' for new check-ins
- Listen: 'sessions:capacity-update' for capacity changes

================================================================================
PROJECT STRUCTURE
================================================================================

lib/
├── main.dart
├── app.dart
├── config/
│   ├── api_config.dart           # Base URLs, timeouts
│   ├── app_config.dart           # App-wide constants
│   └── theme_config.dart         # Theme data
├── models/
│   ├── session.dart              # Session model + status enum
│   ├── session.freezed.dart      # Generated
│   ├── session.g.dart            # Generated
│   ├── participant.dart          # Participant model
│   ├── participant.freezed.dart
│   ├── participant.g.dart
│   ├── checkin.dart              # CheckIn model
│   ├── checkin.freezed.dart
│   ├── checkin.g.dart
│   ├── api_response.dart         # Standard response wrapper
│   ├── api_response.freezed.dart
│   ├── api_response.g.dart
│   └── enums.dart                # All enums
├── providers/
│   ├── api_client_provider.dart  # Dio instance
│   ├── socket_provider.dart      # Socket.io connection
│   ├── sessions_provider.dart    # Sessions state
│   ├── checkin_provider.dart     # Check-in operations
│   ├── offline_queue_provider.dart # Offline sync
│   └── settings_provider.dart    # App settings (server URL, officer name)
├── services/
│   ├── api_service.dart          # HTTP methods
│   ├── session_service.dart      # Session API calls
│   ├── checkin_service.dart      # Check-in API calls
│   ├── participant_service.dart  # Participant API calls
│   ├── socket_service.dart       # WebSocket management
│   └── offline_service.dart      # Local DB + sync
├── screens/
│   ├── splash_screen.dart        # Loading + health check
│   ├── settings_screen.dart      # Configure server URL + officer name
│   ├── home_screen.dart          # Main navigation
│   ├── sessions_screen.dart      # Session list
│   ├── session_detail_screen.dart # Session info + check-ins
│   ├── qr_scanner_screen.dart    # Camera QR scanner
│   ├── manual_checkin_screen.dart # Search + select participant
│   └── checkin_result_screen.dart # Success/error display
├── widgets/
│   ├── session_card.dart         # Session list item
│   ├── session_status_badge.dart # Status indicator
│   ├── participant_tile.dart     # Participant list item
│   ├── checkin_tile.dart         # Check-in list item
│   ├── capacity_indicator.dart   # Progress bar for capacity
│   ├── connection_indicator.dart # Online/offline status
│   ├── loading_overlay.dart      # Full screen loading
│   └── error_dialog.dart         # Standard error display
└── utils/
    ├── extensions.dart           # DateTime, String extensions
    ├── validators.dart           # Input validation
    └── logger.dart               # Debug logging

================================================================================
DEPENDENCIES (pubspec.yaml)
================================================================================

dependencies:
  flutter:
    sdk: flutter
  
  # State Management
  flutter_riverpod: ^2.5.1
  riverpod_annotation: ^2.3.5
  
  # Networking
  dio: ^5.4.0
  socket_io_client: ^2.0.3+1
  connectivity_plus: ^6.0.3
  
  # Code Generation
  freezed_annotation: ^2.4.1
  json_annotation: ^4.8.1
  
  # QR Scanner
  mobile_scanner: ^5.1.1
  
  # Local Storage
  isar: ^3.1.0+1
  isar_flutter_libs: ^3.1.0+1
  shared_preferences: ^2.2.3
  
  # UI Components
  flutter_svg: ^2.0.10+1
  shimmer: ^3.0.0
  
  # Utilities
  intl: ^0.19.0
  logger: ^2.2.0
  permission_handler: ^11.3.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  build_runner: ^2.4.9
  freezed: ^2.5.2
  json_serializable: ^6.7.1
  riverpod_generator: ^2.4.0
  isar_generator: ^3.1.0+1
  flutter_lints: ^4.0.0

================================================================================
DATA MODELS (with Freezed)
================================================================================

// lib/models/enums.dart
enum SessionStatus { scheduled, open, ended, closed, cancelled }
enum CheckInMethod { qr, manual }
enum ParticipantStatus { regular, ambassador, travel_grant }
enum RegistrationStatus { confirmed, pending, cancelled }

// lib/models/session.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'enums.dart';

part 'session.freezed.dart';
part 'session.g.dart';

@freezed
class Session with _$Session {
  const factory Session({
    @JsonKey(name: '_id') required String id,
    required String name,
    String? description,
    required DateTime startTime,
    required DateTime endTime,
    String? location,
    @Default(false) bool isOpen,
    @Default(SessionStatus.scheduled) SessionStatus status,
    @Default(0) int capacity,
    @Default(true) bool capacityEnforced,
    @Default(false) bool requiresRegistration,
    @Default(0) int checkInsCount,
    @Default(1) int day,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _Session;

  factory Session.fromJson(Map<String, dynamic> json) => _$SessionFromJson(json);
}

// lib/models/participant.dart
@freezed
class Participant with _$Participant {
  const factory Participant({
    @JsonKey(name: '_id') required String id,
    required String name,
    required String email,
    String? organization,
    String? phone,
    required String qrCode,
    @Default(true) bool isActive,
    @Default(ParticipantStatus.regular) ParticipantStatus status,
    @Default(0) int ambassadorPoints,
    String? notes,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _Participant;

  factory Participant.fromJson(Map<String, dynamic> json) => _$ParticipantFromJson(json);
}

// lib/models/checkin.dart
@freezed
class CheckIn with _$CheckIn {
  const factory CheckIn({
    @JsonKey(name: '_id') required String id,
    required dynamic participantId,  // String or populated Participant
    required dynamic sessionId,      // String or populated Session
    required DateTime checkInTime,
    @Default(CheckInMethod.manual) CheckInMethod method,
    String? checkedInBy,
    String? notes,
    @Default(false) bool isLate,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _CheckIn;

  factory CheckIn.fromJson(Map<String, dynamic> json) => _$CheckInFromJson(json);
}

// lib/models/api_response.dart
@freezed
class ApiResponse<T> with _$ApiResponse<T> {
  const factory ApiResponse({
    required String status,
    required String message,
    T? data,
    ApiMeta? meta,
    CapacityInfo? capacityInfo,
  }) = _ApiResponse;

  factory ApiResponse.fromJson(
    Map<String, dynamic> json,
    T Function(Object?) fromJsonT,
  ) => _$ApiResponseFromJson(json, fromJsonT);
}

@freezed
class ApiMeta with _$ApiMeta {
  const factory ApiMeta({
    required int total,
    required int page,
    required int limit,
    required int pages,
  }) = _ApiMeta;

  factory ApiMeta.fromJson(Map<String, dynamic> json) => _$ApiMetaFromJson(json);
}

@freezed
class CapacityInfo with _$CapacityInfo {
  const factory CapacityInfo({
    required int current,
    required int capacity,
    required double percentFull,
    required bool isAtCapacity,
    int? remaining,
  }) = _CapacityInfo;

  factory CapacityInfo.fromJson(Map<String, dynamic> json) => _$CapacityInfoFromJson(json);
}

================================================================================
API SERVICE IMPLEMENTATION
================================================================================

// lib/services/api_service.dart
import 'package:dio/dio.dart';
import '../config/api_config.dart';

class ApiService {
  late final Dio _dio;
  
  ApiService(String baseUrl) {
    _dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 10),
      receiveTimeout: const Duration(seconds: 15),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    ));
    
    _dio.interceptors.add(LogInterceptor(
      requestBody: true,
      responseBody: true,
    ));
  }
  
  Future<Response<T>> get<T>(String path, {Map<String, dynamic>? queryParams}) {
    return _dio.get<T>(path, queryParameters: queryParams);
  }
  
  Future<Response<T>> post<T>(String path, {dynamic data}) {
    return _dio.post<T>(path, data: data);
  }
  
  Future<Response<T>> delete<T>(String path) {
    return _dio.delete<T>(path);
  }
}

// lib/services/checkin_service.dart
class CheckInService {
  final ApiService _api;
  
  CheckInService(this._api);
  
  /// QR Code Check-in
  Future<CheckInResult> checkInByQr({
    required String qrCode,
    required String sessionId,
    String? checkedInBy,
  }) async {
    final response = await _api.post('/checkin/qr', data: {
      'qrCode': qrCode,
      'sessionId': sessionId,
      if (checkedInBy != null) 'checkedInBy': checkedInBy,
    });
    
    return CheckInResult.fromJson(response.data);
  }
  
  /// Manual Check-in
  Future<CheckInResult> checkInManual({
    required String participantId,
    required String sessionId,
    String? checkedInBy,
    String? notes,
  }) async {
    final response = await _api.post('/checkin', data: {
      'participantId': participantId,
      'sessionId': sessionId,
      'method': 'manual',
      if (checkedInBy != null) 'checkedInBy': checkedInBy,
      if (notes != null) 'notes': notes,
    });
    
    return CheckInResult.fromJson(response.data);
  }
  
  /// Verify if already checked in
  Future<bool> isCheckedIn(String participantId, String sessionId) async {
    final response = await _api.get('/checkin/verify/$participantId/$sessionId');
    return response.data['data']['isCheckedIn'] ?? false;
  }
  
  /// Undo check-in
  Future<void> undoCheckIn(String checkInId) async {
    await _api.delete('/checkin/$checkInId');
  }
}

================================================================================
WEBSOCKET SERVICE IMPLEMENTATION
================================================================================

// lib/services/socket_service.dart
import 'package:socket_io_client/socket_io_client.dart' as IO;

class SocketService {
  IO.Socket? _socket;
  final String baseUrl;
  
  // Callbacks
  Function(bool)? onConnectionChange;
  Function(SessionStatusUpdate)? onSessionStatusUpdate;
  Function(CheckInUpdate)? onCheckInUpdate;
  Function(CapacityUpdate)? onCapacityUpdate;
  
  SocketService(this.baseUrl);
  
  void connect() {
    _socket = IO.io(
      '$baseUrl/realtime',
      IO.OptionBuilder()
        .setTransports(['websocket', 'polling'])
        .enableAutoConnect()
        .enableReconnection()
        .setReconnectionAttempts(5)
        .setReconnectionDelay(2000)
        .build(),
    );
    
    _socket!.onConnect((_) {
      print('WebSocket connected');
      onConnectionChange?.call(true);
      subscribeToSessions();
    });
    
    _socket!.onDisconnect((_) {
      print('WebSocket disconnected');
      onConnectionChange?.call(false);
    });
    
    _socket!.on('sessions:status-update', (data) {
      final update = SessionStatusUpdate.fromJson(data['data']);
      onSessionStatusUpdate?.call(update);
    });
    
    _socket!.on('sessions:checkin', (data) {
      final update = CheckInUpdate.fromJson(data['data']);
      onCheckInUpdate?.call(update);
    });
    
    _socket!.on('sessions:capacity-update', (data) {
      final update = CapacityUpdate.fromJson(data['data']);
      onCapacityUpdate?.call(update);
    });
  }
  
  void subscribeToSessions() {
    _socket?.emit('subscribe:sessions');
  }
  
  void disconnect() {
    _socket?.disconnect();
    _socket?.dispose();
    _socket = null;
  }
  
  bool get isConnected => _socket?.connected ?? false;
}

================================================================================
STATE MANAGEMENT (Riverpod)
================================================================================

// lib/providers/sessions_provider.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../models/session.dart';
import '../services/session_service.dart';

part 'sessions_provider.g.dart';

@riverpod
class Sessions extends _$Sessions {
  @override
  Future<List<Session>> build() async {
    final service = ref.watch(sessionServiceProvider);
    final result = await service.getSessions();
    return result.data ?? [];
  }
  
  void updateSessionStatus(String sessionId, SessionStatus newStatus, bool isOpen) {
    state.whenData((sessions) {
      final updated = sessions.map((s) {
        if (s.id == sessionId) {
          return s.copyWith(status: newStatus, isOpen: isOpen);
        }
        return s;
      }).toList();
      state = AsyncData(updated);
    });
  }
  
  void incrementCheckInCount(String sessionId) {
    state.whenData((sessions) {
      final updated = sessions.map((s) {
        if (s.id == sessionId) {
          return s.copyWith(checkInsCount: s.checkInsCount + 1);
        }
        return s;
      }).toList();
      state = AsyncData(updated);
    });
  }
  
  Future<void> refresh() async {
    ref.invalidateSelf();
  }
}

// lib/providers/checkin_provider.dart
@riverpod
class CheckInNotifier extends _$CheckInNotifier {
  @override
  AsyncValue<CheckInResult?> build() => const AsyncData(null);
  
  Future<void> checkInByQr({
    required String qrCode,
    required String sessionId,
  }) async {
    state = const AsyncLoading();
    try {
      final service = ref.read(checkInServiceProvider);
      final settings = ref.read(settingsProvider);
      
      final result = await service.checkInByQr(
        qrCode: qrCode,
        sessionId: sessionId,
        checkedInBy: settings.officerName,
      );
      
      state = AsyncData(result);
      
      // Update session check-in count
      ref.read(sessionsProvider.notifier).incrementCheckInCount(sessionId);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }
  
  Future<void> checkInManual({
    required String participantId,
    required String sessionId,
  }) async {
    state = const AsyncLoading();
    try {
      final service = ref.read(checkInServiceProvider);
      final settings = ref.read(settingsProvider);
      
      final result = await service.checkInManual(
        participantId: participantId,
        sessionId: sessionId,
        checkedInBy: settings.officerName,
      );
      
      state = AsyncData(result);
      
      ref.read(sessionsProvider.notifier).incrementCheckInCount(sessionId);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }
  
  void reset() {
    state = const AsyncData(null);
  }
}

================================================================================
SCREEN IMPLEMENTATIONS
================================================================================

--------------------------------------------------------------------------------
1. SPLASH SCREEN - Health check + auto-navigate
--------------------------------------------------------------------------------

// lib/screens/splash_screen.dart
class SplashScreen extends ConsumerStatefulWidget {
  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen> {
  @override
  void initState() {
    super.initState();
    _checkConnection();
  }
  
  Future<void> _checkConnection() async {
    final settings = ref.read(settingsProvider);
    
    if (settings.serverUrl.isEmpty) {
      // First launch - go to settings
      Navigator.pushReplacementNamed(context, '/settings');
      return;
    }
    
    try {
      final api = ref.read(apiServiceProvider);
      await api.get('/health/live');
      // Connection OK - go to home
      Navigator.pushReplacementNamed(context, '/home');
    } catch (e) {
      // Show error, allow manual retry or settings
      _showConnectionError();
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Image.asset('assets/logo.png', width: 120),
            const SizedBox(height: 24),
            const Text('IASTAM Officer Check-In', style: TextStyle(fontSize: 24)),
            const SizedBox(height: 32),
            const CircularProgressIndicator(),
            const SizedBox(height: 16),
            const Text('Connecting to server...'),
          ],
        ),
      ),
    );
  }
}

--------------------------------------------------------------------------------
2. SESSIONS SCREEN - List with real-time updates
--------------------------------------------------------------------------------

// lib/screens/sessions_screen.dart
class SessionsScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sessionsAsync = ref.watch(sessionsProvider);
    final isConnected = ref.watch(socketConnectionProvider);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Sessions'),
        actions: [
          ConnectionIndicator(isConnected: isConnected),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => ref.invalidate(sessionsProvider),
          ),
        ],
      ),
      body: sessionsAsync.when(
        loading: () => const SessionsListShimmer(),
        error: (e, st) => ErrorRetryWidget(
          error: e.toString(),
          onRetry: () => ref.invalidate(sessionsProvider),
        ),
        data: (sessions) {
          // Sort: open first, then by startTime
          final sorted = [...sessions]..sort((a, b) {
            if (a.isOpen && !b.isOpen) return -1;
            if (!a.isOpen && b.isOpen) return 1;
            return a.startTime.compareTo(b.startTime);
          });
          
          return RefreshIndicator(
            onRefresh: () => ref.read(sessionsProvider.notifier).refresh(),
            child: ListView.builder(
              itemCount: sorted.length,
              itemBuilder: (context, index) {
                final session = sorted[index];
                return SessionCard(
                  session: session,
                  onTap: () => Navigator.pushNamed(
                    context,
                    '/session-detail',
                    arguments: session.id,
                  ),
                );
              },
            ),
          );
        },
      ),
    );
  }
}

--------------------------------------------------------------------------------
3. SESSION DETAIL - Info + Check-in buttons
--------------------------------------------------------------------------------

// lib/screens/session_detail_screen.dart
class SessionDetailScreen extends ConsumerWidget {
  final String sessionId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sessionsAsync = ref.watch(sessionsProvider);
    
    return sessionsAsync.when(
      loading: () => const LoadingScaffold(),
      error: (e, _) => ErrorScaffold(error: e.toString()),
      data: (sessions) {
        final session = sessions.firstWhere((s) => s.id == sessionId);
        
        return Scaffold(
          appBar: AppBar(title: Text(session.name)),
          body: SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Status Badge
                SessionStatusBadge(status: session.status, isOpen: session.isOpen),
                const SizedBox(height: 16),
                
                // Session Info Card
                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (session.description != null) ...[
                          Text(session.description!),
                          const Divider(),
                        ],
                        _InfoRow(Icons.access_time, _formatTime(session)),
                        _InfoRow(Icons.location_on, session.location ?? 'TBD'),
                        _InfoRow(Icons.calendar_today, 'Day ${session.day}'),
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                
                // Capacity Indicator
                if (session.capacity > 0)
                  CapacityIndicator(
                    current: session.checkInsCount,
                    capacity: session.capacity,
                  ),
                const SizedBox(height: 24),
                
                // Check-in Buttons (only if open)
                if (session.isOpen) ...[
                  SizedBox(
                    width: double.infinity,
                    height: 56,
                    child: ElevatedButton.icon(
                      icon: const Icon(Icons.qr_code_scanner, size: 28),
                      label: const Text('SCAN QR CODE', style: TextStyle(fontSize: 18)),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Theme.of(context).primaryColor,
                        foregroundColor: Colors.white,
                      ),
                      onPressed: () => Navigator.pushNamed(
                        context,
                        '/qr-scanner',
                        arguments: session.id,
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  SizedBox(
                    width: double.infinity,
                    height: 48,
                    child: OutlinedButton.icon(
                      icon: const Icon(Icons.person_search),
                      label: const Text('MANUAL CHECK-IN'),
                      onPressed: () => Navigator.pushNamed(
                        context,
                        '/manual-checkin',
                        arguments: session.id,
                      ),
                    ),
                  ),
                ] else
                  const Center(
                    child: Text(
                      'Check-in is not available for this session',
                      style: TextStyle(color: Colors.grey, fontSize: 16),
                    ),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }
}

--------------------------------------------------------------------------------
4. QR SCANNER SCREEN - Camera + instant check-in
--------------------------------------------------------------------------------

// lib/screens/qr_scanner_screen.dart
import 'package:mobile_scanner/mobile_scanner.dart';

class QrScannerScreen extends ConsumerStatefulWidget {
  final String sessionId;
  
  @override
  ConsumerState<QrScannerScreen> createState() => _QrScannerScreenState();
}

class _QrScannerScreenState extends ConsumerState<QrScannerScreen> {
  final MobileScannerController _controller = MobileScannerController(
    detectionSpeed: DetectionSpeed.noDuplicates,
    facing: CameraFacing.back,
    torchEnabled: false,
  );
  
  bool _isProcessing = false;
  
  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
  
  Future<void> _onDetect(BarcodeCapture capture) async {
    if (_isProcessing) return;
    
    final qrCode = capture.barcodes.firstOrNull?.rawValue;
    if (qrCode == null || !qrCode.startsWith('QR-')) return;
    
    setState(() => _isProcessing = true);
    
    // Pause camera
    await _controller.stop();
    
    // Perform check-in
    await ref.read(checkInNotifierProvider.notifier).checkInByQr(
      qrCode: qrCode,
      sessionId: widget.sessionId,
    );
    
    // Navigate to result screen
    if (mounted) {
      Navigator.pushReplacementNamed(context, '/checkin-result');
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scan QR Code'),
        actions: [
          IconButton(
            icon: ValueListenableBuilder(
              valueListenable: _controller.torchState,
              builder: (context, state, child) => Icon(
                state == TorchState.on ? Icons.flash_on : Icons.flash_off,
              ),
            ),
            onPressed: () => _controller.toggleTorch(),
          ),
        ],
      ),
      body: Stack(
        children: [
          MobileScanner(
            controller: _controller,
            onDetect: _onDetect,
          ),
          
          // Overlay with scan area
          CustomPaint(
            painter: ScanOverlayPainter(),
            child: const SizedBox.expand(),
          ),
          
          // Instructions
          Positioned(
            bottom: 100,
            left: 0,
            right: 0,
            child: Text(
              'Position QR code within the frame',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Colors.white,
                fontSize: 16,
                shadows: [Shadow(blurRadius: 10, color: Colors.black)],
              ),
            ),
          ),
          
          if (_isProcessing)
            Container(
              color: Colors.black54,
              child: const Center(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    CircularProgressIndicator(color: Colors.white),
                    SizedBox(height: 16),
                    Text('Processing...', style: TextStyle(color: Colors.white)),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }
}

--------------------------------------------------------------------------------
5. MANUAL CHECK-IN SCREEN - Search + select
--------------------------------------------------------------------------------

// lib/screens/manual_checkin_screen.dart
class ManualCheckInScreen extends ConsumerStatefulWidget {
  final String sessionId;
  
  @override
  ConsumerState<ManualCheckInScreen> createState() => _ManualCheckInScreenState();
}

class _ManualCheckInScreenState extends ConsumerState<ManualCheckInScreen> {
  final _searchController = TextEditingController();
  List<Participant> _results = [];
  bool _isSearching = false;
  
  Future<void> _search(String query) async {
    if (query.length < 2) {
      setState(() => _results = []);
      return;
    }
    
    setState(() => _isSearching = true);
    
    try {
      final service = ref.read(participantServiceProvider);
      final result = await service.searchParticipants(query);
      setState(() => _results = result.data ?? []);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Search failed: $e')),
      );
    } finally {
      setState(() => _isSearching = false);
    }
  }
  
  Future<void> _checkIn(Participant participant) async {
    // First verify not already checked in
    final checkInService = ref.read(checkInServiceProvider);
    final alreadyCheckedIn = await checkInService.isCheckedIn(
      participant.id,
      widget.sessionId,
    );
    
    if (alreadyCheckedIn) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Participant already checked in!'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }
    
    // Perform check-in
    await ref.read(checkInNotifierProvider.notifier).checkInManual(
      participantId: participant.id,
      sessionId: widget.sessionId,
    );
    
    Navigator.pushReplacementNamed(context, '/checkin-result');
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Manual Check-In')),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search by name or email...',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchController.text.isNotEmpty
                  ? IconButton(
                      icon: const Icon(Icons.clear),
                      onPressed: () {
                        _searchController.clear();
                        setState(() => _results = []);
                      },
                    )
                  : null,
                border: const OutlineInputBorder(),
              ),
              onChanged: (value) => _search(value),
            ),
          ),
          
          if (_isSearching)
            const LinearProgressIndicator(),
          
          Expanded(
            child: _results.isEmpty
              ? Center(
                  child: Text(
                    _searchController.text.isEmpty
                      ? 'Enter name or email to search'
                      : 'No participants found',
                    style: const TextStyle(color: Colors.grey),
                  ),
                )
              : ListView.builder(
                  itemCount: _results.length,
                  itemBuilder: (context, index) {
                    final participant = _results[index];
                    return ParticipantTile(
                      participant: participant,
                      onTap: () => _checkIn(participant),
                    );
                  },
                ),
          ),
        ],
      ),
    );
  }
}

--------------------------------------------------------------------------------
6. CHECK-IN RESULT SCREEN - Success/error feedback
--------------------------------------------------------------------------------

// lib/screens/checkin_result_screen.dart
class CheckInResultScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final checkInState = ref.watch(checkInNotifierProvider);
    
    return checkInState.when(
      loading: () => const LoadingScaffold(message: 'Processing check-in...'),
      error: (e, _) => _ErrorResult(error: e.toString(), ref: ref),
      data: (result) => result == null
        ? const LoadingScaffold()
        : _SuccessResult(result: result, ref: ref),
    );
  }
}

class _SuccessResult extends StatelessWidget {
  final CheckInResult result;
  final WidgetRef ref;
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.check_circle, size: 120, color: Colors.green),
              const SizedBox(height: 24),
              const Text(
                'Check-In Successful!',
                style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              Text(
                result.participant?.name ?? 'Unknown',
                style: const TextStyle(fontSize: 22),
              ),
              if (result.participant?.organization != null) ...[
                const SizedBox(height: 8),
                Text(
                  result.participant!.organization!,
                  style: const TextStyle(fontSize: 16, color: Colors.grey),
                ),
              ],
              const SizedBox(height: 32),
              if (result.capacityInfo != null) ...[
                CapacityIndicator(
                  current: result.capacityInfo!.current,
                  capacity: result.capacityInfo!.capacity,
                ),
                const SizedBox(height: 32),
              ],
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () {
                        ref.read(checkInNotifierProvider.notifier).reset();
                        Navigator.pop(context);
                      },
                      child: const Text('BACK'),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: ElevatedButton.icon(
                      icon: const Icon(Icons.qr_code_scanner),
                      label: const Text('SCAN NEXT'),
                      onPressed: () {
                        ref.read(checkInNotifierProvider.notifier).reset();
                        Navigator.pop(context); // Back to scanner
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ErrorResult extends StatelessWidget {
  final String error;
  final WidgetRef ref;
  
  @override
  Widget build(BuildContext context) {
    // Parse error for user-friendly message
    String message = error;
    Color iconColor = Colors.red;
    IconData icon = Icons.error;
    
    if (error.contains('already checked in')) {
      message = 'Already Checked In';
      iconColor = Colors.orange;
      icon = Icons.info;
    } else if (error.contains('not open')) {
      message = 'Session Not Open';
    } else if (error.contains('at capacity')) {
      message = 'Session at Capacity';
    } else if (error.contains('not registered')) {
      message = 'Not Registered for Session';
    } else if (error.contains('not found')) {
      message = 'Participant Not Found';
    }
    
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, size: 120, color: iconColor),
              const SizedBox(height: 24),
              Text(
                message,
                style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              Text(
                error,
                style: const TextStyle(color: Colors.grey),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    ref.read(checkInNotifierProvider.notifier).reset();
                    Navigator.pop(context);
                  },
                  child: const Text('TRY AGAIN'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

================================================================================
OFFLINE SUPPORT (OPTIONAL ENHANCEMENT)
================================================================================

// lib/services/offline_service.dart
// Uses Isar for local database to queue check-ins when offline

@Collection()
class PendingCheckIn {
  Id id = Isar.autoIncrement;
  late String qrCode;
  late String sessionId;
  late String? checkedInBy;
  late DateTime createdAt;
  late int retryCount;
}

class OfflineService {
  late Isar _isar;
  
  Future<void> init() async {
    _isar = await Isar.open([PendingCheckInSchema]);
  }
  
  Future<void> queueCheckIn(String qrCode, String sessionId, String? checkedInBy) async {
    final pending = PendingCheckIn()
      ..qrCode = qrCode
      ..sessionId = sessionId
      ..checkedInBy = checkedInBy
      ..createdAt = DateTime.now()
      ..retryCount = 0;
    
    await _isar.writeTxn(() => _isar.pendingCheckIns.put(pending));
  }
  
  Future<void> syncPendingCheckIns(CheckInService checkInService) async {
    final pending = await _isar.pendingCheckIns.where().findAll();
    
    for (final item in pending) {
      try {
        await checkInService.checkInByQr(
          qrCode: item.qrCode,
          sessionId: item.sessionId,
          checkedInBy: item.checkedInBy,
        );
        
        await _isar.writeTxn(() => _isar.pendingCheckIns.delete(item.id));
      } catch (e) {
        // If 409 (already checked in), remove from queue
        if (e.toString().contains('409')) {
          await _isar.writeTxn(() => _isar.pendingCheckIns.delete(item.id));
        } else {
          // Increment retry count
          item.retryCount++;
          await _isar.writeTxn(() => _isar.pendingCheckIns.put(item));
        }
      }
    }
  }
  
  int get pendingCount => _isar.pendingCheckIns.countSync();
}

================================================================================
THEME CONFIGURATION
================================================================================

// lib/config/theme_config.dart
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get light => ThemeData(
    useMaterial3: true,
    colorScheme: ColorScheme.fromSeed(
      seedColor: const Color(0xFF1E88E5),  // IASTAM Blue
      brightness: Brightness.light,
    ),
    appBarTheme: const AppBarTheme(
      centerTitle: true,
      elevation: 0,
    ),
    cardTheme: CardTheme(
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
      ),
    ),
    inputDecorationTheme: InputDecorationTheme(
      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
      filled: true,
    ),
  );
  
  static ThemeData get dark => ThemeData(
    useMaterial3: true,
    colorScheme: ColorScheme.fromSeed(
      seedColor: const Color(0xFF1E88E5),
      brightness: Brightness.dark,
    ),
  );
}

================================================================================
APP ENTRY POINT
================================================================================

// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'app.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(const ProviderScope(child: IastamCheckInApp()));
}

// lib/app.dart
class IastamCheckInApp extends ConsumerWidget {
  const IastamCheckInApp({super.key});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      title: 'IASTAM Officer Check-In',
      theme: AppTheme.light,
      darkTheme: AppTheme.dark,
      themeMode: ThemeMode.system,
      debugShowCheckedModeBanner: false,
      initialRoute: '/splash',
      routes: {
        '/splash': (_) => const SplashScreen(),
        '/settings': (_) => const SettingsScreen(),
        '/home': (_) => const HomeScreen(),
        '/sessions': (_) => const SessionsScreen(),
        '/session-detail': (context) {
          final sessionId = ModalRoute.of(context)!.settings.arguments as String;
          return SessionDetailScreen(sessionId: sessionId);
        },
        '/qr-scanner': (context) {
          final sessionId = ModalRoute.of(context)!.settings.arguments as String;
          return QrScannerScreen(sessionId: sessionId);
        },
        '/manual-checkin': (context) {
          final sessionId = ModalRoute.of(context)!.settings.arguments as String;
          return ManualCheckInScreen(sessionId: sessionId);
        },
        '/checkin-result': (_) => const CheckInResultScreen(),
      },
    );
  }
}

================================================================================
TESTING CHECKLIST
================================================================================

1. Connection Tests:
   [ ] App connects to backend on startup
   [ ] Shows error if server unreachable
   [ ] WebSocket connects and receives updates
   [ ] Reconnects after disconnect

2. Session List Tests:
   [ ] Displays all sessions
   [ ] Shows correct status badges
   [ ] Updates in real-time when status changes
   [ ] Pull-to-refresh works

3. QR Scanner Tests:
   [ ] Camera opens without issues
   [ ] Scans QR codes quickly
   [ ] Handles invalid QR codes gracefully
   [ ] Flash toggle works
   [ ] Shows success screen on check-in
   [ ] Shows appropriate error for duplicates

4. Manual Check-in Tests:
   [ ] Search returns correct results
   [ ] Handles empty search gracefully
   [ ] Prevents duplicate check-ins
   [ ] Shows success/error appropriately

5. Error Handling Tests:
   [ ] "Session not open" error displays correctly
   [ ] "Already checked in" shows as warning, not error
   [ ] "At capacity" error displays correctly
   [ ] "Not registered" error displays correctly
   [ ] Network timeout handled gracefully

6. Offline Tests (if implemented):
   [ ] Check-ins queue when offline
   [ ] Syncs when back online
   [ ] Shows pending count indicator
   [ ] Handles sync conflicts (duplicates)

================================================================================
BUILD & DEPLOYMENT
================================================================================

Android:
  flutter build apk --release
  flutter build appbundle --release

iOS:
  flutter build ios --release

Environment Configuration:
  - Use --dart-define for environment variables
  - flutter run --dart-define=BASE_URL=http://192.168.1.100:3000/api/v1

================================================================================
END OF PROMPT
================================================================================
